#!/usr/bin/env python3
# SPDX-FileCopyrightText: 2025 Ayumu Saito
# SPDX-License-Identifier: BSD-3-Clause

import sys
import math
import argparse

def die(msg):
    """エラーメッセージをstderrに出力して終了コード1で終了"""
    print("error: " + msg, file=sys.stderr)
    sys.exit(1)

def main():
    parser = argparse.ArgumentParser(description="標準入力から数値を読み取り、正規化して出力します。")
    parser.add_argument("-z", "--zscore", action="store_true", help="Zスコア正規化を行います（デフォルトはmin-max）")
    parser.add_argument("-p", "--precision", type=int, default=3, help="小数点以下の桁数を指定します（デフォルト: 3）")
    
    args = parser.parse_args()

    if args.precision < 0 or args.precision > 10:
        die("--precision must be between 0 and 10")

    nums = []
    
    try:
        for i, line in enumerate(sys.stdin, start=1):
            s = line.strip()
            if (not s) or s.startswith("#"):
                continue
            try:
                val = float(s)
                if not math.isfinite(val):
                    die(f"value is infinite or NaN at line {i}: '{s}'")
                nums.append(val)
            except ValueError:
                die(f"not a number at line {i}: '{s}'")
    except KeyboardInterrupt:
        sys.exit(1)

    if not nums:
        die("no numbers on stdin")

    fmt = "{:." + str(args.precision) + "f}"

    if args.zscore:
        m = sum(nums) / len(nums)
        v = sum((x - m) ** 2 for x in nums) / len(nums)
        sd = math.sqrt(v)
        
        if sd == 0.0:
            die("std is zero (all numbers are the same)")
        
        for x in nums:
            print(fmt.format((x - m) / sd))
            
    else:
        mn, mx = min(nums), max(nums)
        if mx == mn:
            die("min == max (all numbers are the same)")
        
        d = mx - mn
        for x in nums:
            print(fmt.format((x - mn) / d))

if __name__ == "__main__":
    main()
